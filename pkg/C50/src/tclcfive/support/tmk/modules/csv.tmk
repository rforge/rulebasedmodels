# -*-Mode: tcl -*-

# =============================================================================
# csv.tmk: tmk module for generating LaTeX tables from comma separated value
# files such as spreadsheets
#
# (C) Wolfgang Heidrich (heidrich@cs.ubc.ca)
# =============================================================================
# $Log: csv.tmk,v $
# Revision 1.2  2004/10/08 03:14:08  wheidrich
# fixed some quotation problems (dollar signs etc.)
#
# Revision 1.1  2004/09/15 06:06:20  wheidrich
# create LaTeX tables from comma separated value files (spreadheets)
#
# Revision 1.2  2004/09/05 17:37:37  heidrich
# *** empty log message ***
#
# Revision 1.1  2004/09/05 17:26:45  heidrich
# *** empty log message ***
#
#
# =============================================================================

# should be empty on default
set_ifndef EXCLUDE           {}

# configure which output to generate (LaTeX is the only option right now)
set_ifndef USE_AUTO_TEX 1

# layout configuration
set_ifndef DRAW_FRAME 1
set_ifndef COLUMN_SEPARATORS 1
set_ifndef ROW_SEPARATORS 0

# symbols used in the csv file
set_ifndef SEPARATOR {,}
set_ifndef LINE_SEPARATOR {---}
set_ifndef QUOTE {\"}

# --------------------------------- end of configuration -------------------

# this is the list of files we want to remove on a clean
set CLEANFILELIST {}


# On a make clean we remove all files that could be generated by this
# module.  This may not remove all files (e.g. when helper files are
# manually removed before tmk clean is called), but this is better
# than removing tex files that we are not supposed to...
depend clean csvclean
target csvclean ALWAYS_BUILD {
    eval cmd rm -f $csv::CLEANFILELIST
}

proc fixQuotedSeps fields {
    if {[llength $fields] == 0} {
        return {}
    }
    if [regexp "^$csv::QUOTE\[^$csv::QUOTE\]*$csv::QUOTE\$" [lindex $fields 0]] {
        return [concat [list [lindex $fields 0]] [fixQuotedSeps [lrange $fields 1 end]]]
    }
    if [regexp "^$csv::QUOTE" [lindex $fields 0]] {
        return [fixQuotedSeps [concat [list "[lindex $fields 0]$csv::SEPARATOR[lindex $fields 1]"
] [lrange $fields 2 end]]]
    } else {
        return [concat [list [lindex $fields 0]] [fixQuotedSeps [lrange $fields 1 end]]]
    }
}


target *.tex {$ROOT.csv} {

    # this will NOT land in the $ARCH directory
    set TARGET [targetname_short $TARGET]
    set ROOT   [file rootname   $TARGET]
    
    # read input and split it into lines
    set inFile [open $SRC]
    set tmp [split [read $inFile] "\n"]
    regsub -all {\$} $tmp {\\$} table
    set numColumns [llength [csv::fixQuotedSeps [split [lindex $table 0] $csv::SEPARATOR]]]
    
    # Empty rows consist only of separators
    set separatorRow $csv::LINE_SEPARATOR
    for {set i 1} {$i< $numColumns} {incr i} {
	append separatorRow "$csv::SEPARATOR$csv::LINE_SEPARATOR"
    }

    set outFile [open $TARGET w]
    log_msg "Creating $TARGET..."
    
    #
    # specify table header
    #
    puts $outFile "\\begin\{tabular\}\{" nonewline
    # left delimiter if we want a frame
    if {$csv::DRAW_FRAME} {
	puts $outFile "|" nonewline
    }
    # first column is left centered
    puts $outFile "l" nonewline
    for {set i 1} {$i < $numColumns} {incr i} {
	# do we need separators between the columns?
	if {$csv::COLUMN_SEPARATORS} {
	    puts $outFile "|" nonewline
	}
	# the second and higher columns are right aligned
	puts $outFile "r" nonewline
    }
    # right delimiter if we want a frame
    if {$csv::DRAW_FRAME} {
	puts $outFile "|" nonewline
    }
    puts $outFile "\}"
    # draw top edge of frame if desired
    if {$csv::DRAW_FRAME} {
	puts $outFile "  \\hline"
    }
    #
    # end table header
    #
    
    #
    # loop over table rows
    #
    set firstLine 1
    foreach row $table {
	# add horizontal separator here
	if {$row == $separatorRow} {
	    puts $outFile "  \\hline"
	} else {
	    set entries [csv::fixQuotedSeps [split $row $csv::SEPARATOR]]
	    regsub -all $csv::QUOTE $entries "" entries

	    # not a line of the atable at all - no separating characters...
	    if {[llength $entries] == 0 } {
		continue
	    }
	    
	    # regular line

	    # draw horizontal separator if desired and this isn't the first row
	    if {[expr $csv::ROW_SEPARATORS && !$firstLine]} {
		puts $outFile "  \\hline"
	    }
	    set firstLine 0
	    puts $outFile "  [lindex $entries 0]" nonewline
	    for {set i 1} {$i< $numColumns} {incr i} {
		puts $outFile " & [lindex $entries $i]" nonewline
	    }
	    puts $outFile " \\\\"
	}
    }
    
    # footer: draw bottom edge of frame if desired
    if {$csv::DRAW_FRAME} {
	puts $outFile "  \\hline"
    }
    puts $outFile "\\end\{tabular\}"
}


set CSVFILES [glob -nocomplain *.csv]

# loop over all possible files
foreach csvfile $CSVFILES {
    
    set csvname [file rootname $csvfile].csv
    set texname [file rootname $csvfile].tex

    depend $texname $csvname
}

eval_later {
    
    # automatically build .tex's?
    if $USE_AUTO_TEX {
        set texfiles [lmap $CSVFILES {$IROOT.tex}]
        build [lminus $texfiles $EXCLUDE]
	set csv::CLEANFILELIST [concat $csv::CLEANFILELIST $texfiles]
    }
    
    # automatically build .eps's?
#    if $USE_AUTO_EPS {
#        set epsfiles [lmap $GPLFILES {$IROOT.eps}]
#        build [lminus $epsfiles $EXCLUDE]
#	set gnuplot::CLEANFILELIST [concat $gnuplot::CLEANFILELIST $epsfiles]
#    }
}
